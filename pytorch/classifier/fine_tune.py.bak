'''https://github.com/pytorch/examples/tree/master/imagenet
'''
import os
import time
import torch
import torch.nn as nn
import torch.optim as optim
import torch.backends.cudnn as cudnn
import torchvision
import torchvision.transforms as transforms
import torchvision.datasets as datasets
import torchvision.models as models
from easydict import EasyDict as edict
from pyhej.pytorch.classifier.tools import ImageFolder, adjust_learning_rate, train, validate, save_checkpoint


cfg = edict()
cfg.data = ''
cfg.use_cuda = True
cfg.model_name = 'resnet50'
cfg.pretrained = True
cfg.num_classes = 100
cfg.start_epoch = 0
cfg.best_accs = [0,]
cfg.resume = ''
cfg.lr = 0.01
cfg.momentum = 0.9
cfg.weight_decay = 5e-4
cfg.batch_size = 64
cfg.workers = 8


# create model
model = models.__dict__[cfg.model_name](pretrained=cfg.pretrained, num_classes=cfg.num_classes)
model = nn.DataParallel(model)


# define loss function (criterion) and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(model.parameters(), cfg.lr, momentum=cfg.momentum, weight_decay=cfg.weight_decay)


if cfg.use_cuda and torch.cuda.is_available():
    model = model.cuda()
    criterion = criterion.cuda()


if os.path.isfile(cfg.resume):
    checkpoint = torch.load(cfg.resume)
    cfg.start_epoch = checkpoint['epoch']
    cfg.best_accs = checkpoint['best_accs']
    model.load_state_dict(checkpoint['state_dict'])
    optimizer.load_state_dict(checkpoint['optimizer'])


cudnn.benchmark = True


# # Data loading code
traindir, valdir = os.path.join(cfg.data, 'train'), os.path.join(cfg.data, 'val')
train_dataset = ImageFolder(traindir,
    transforms.Compose([
        # new version replace with `Resize`
        transforms.Scale((256, 256)),
        # you want to try `RandomSizedCrop`
        transforms.RandomCrop(224, padding=0),
        transforms.RandomHorizontalFlip(),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
    ]))
train_loader = torch.utils.data.DataLoader(train_dataset, batch_size=cfg.batch_size, shuffle=True, num_workers=cfg.workers, pin_memory=True)
val_dataset = ImageFolder(valdir,
    transforms.Compose([
        # new version replace with `Resize`
        transforms.Scale((256, 256)),
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225]),
    ]))
val_loader = torch.utils.data.DataLoader(val_dataset, batch_size=cfg.batch_size, shuffle=False, num_workers=cfg.workers, pin_memory=True)


for epoch in range(cfg.start_epoch, cfg.start_epoch+cfg.epochs):
    adjust_learning_rate(optimizer, epoch)
    # train for one epoch
    train(train_loader, model, criterion, optimizer, epoch)
    # evaluate on validation set
    best_accs = validate(val_loader, model, criterion)
    # remember best and save checkpoint
    is_best = best_accs[0] > cfg.best_accs[0]
    if is_best:
        cfg.best_accs = best_accs
    save_checkpoint({
        'epoch': epoch,
        'best_accs': best_accs,
        'state_dict': model.state_dict(),
        'optimizer': optimizer.state_dict()
    }, is_best)




